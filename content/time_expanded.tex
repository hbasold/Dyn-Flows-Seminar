\section{Zeiterweiterte Netzwerke}

Unser Ziel ist ein polynomielles Approximationsschema für Quickest-Flow-Probleme.
Die Idee dabei ist, ein Netzwerk $\graph$ in ein \term{zeit-erweitertes Netzwerk}
umzuwandeln. Dazu werden für jeden Zeitschritt Kopien der Knoten von $\graph$
angelegt. Dabei gibt die Zeitkomponente den Zeitpunkt eines Flusses an. Daher
werden in dem neuen Graph zwei Knoten verbunden, genau dann wenn die Knoten
im ursprünglichen Graphen durch eine Kante $e \in \A$ verbunden gewesen sind und
sie $\tau(e)$ Zeitschritte entfernt sind. Zusätzlich müssen wir noch Kanten
zwischen den einzelnen Zeitschritte der Quellen und Senken einfügen, damit
der Fluss auch am Ende der Zeit des Flusses verfügbar ist, denn wir werden
die Kopien der Senken zum Zeitpunkt $T-1$ als neue Senken erklären.

Wir nehmen dabei an, dass die Zeiten ganzzahlig sind. Dies ist durch Skalierung
der Zeit auf die gewünschte Genauigkeit für Anwendungen problemlos möglich.

\begin{definition}[zeiterweitertes Netzwerk]
    Sei $(\graph, \tau)$ ein Netzwerk mit $\tau(e) \in \N$ für alle $e \in \A$
    und $T \in \N$. Setze $\timeDom = \{0, 1, \ldots, T-1\}$.
    Wir definieren damit das \term{zeiterweiterte Netzwerk} $\tExp{T} = (V^T, \A^T)$
    mit
    \begin{itemize}
        \item $V^T = V \times \timeDom$ (schreibe $v_t = (v, t)$ und
            $V_t = \{v_t \in V^T\}$)
        \item $\A^T = \setDef{e_t = (v_t, u_{t + \tau(e)})}
                        {e = (v, u) \in \A \text{ und } t, t + \tau(e) \in \timeDom}
                    \cup H$ \\
            mit „\term{holdover arcs}“ bzw. \term{Speicherkanten} \\
            $H = \setDef{(v_t, v_{t+1})}
                        {v \in S_i \text{ und } t, t + 1 \in \timeDom}$
        \item $\func{u^T}{\A^T}{\REx = \R \cup \{\infty\}}$ mit
                $u^T(e_t) = \begin{cases}
                    u(e)    &, e_t \not\in H \\
                    \infty  &, e_t \in H
                \end{cases}$
        \item $\func{c^T}{\A^T}{\R}$ mit
                $c^T(e_t) = \begin{cases}
                    c(e)    &, e_t \not\in H \\
                    0       &, e_t \in H
                \end{cases}$
        \item $S_i^{+,T} = \setDef{v_0 \in V^T}{v \in S_i^+}$, \\
                $S_i^{-,T} = \setDef{v_{T-1} \in V^T}{v \in S_i^-}$ und damit \\
                $S_i^T = S_i^{+,T} \disjUnion S_i^{-,T}$
    \end{itemize}
    Sollte Speicher an Knoten $V \setminus S$ zugelassen sein, dann müssen analog
    zu $H$ weitere Speicherkanten eingefügt werden.
\end{definition}

\begin{remark}
    Da in Netzwerken $\inEdges(s) = \emptyset$ für alle $s \in S_i^+$ und
    $\outEdges(t) = \emptyset$ für alle $t \in S_i^-$ (d.h. Quellen und Senken
    können keine inneren Knoten auf Flüssen sein), kann in der obigen Definition
    auch $\REx$ durch $\R$ ersetzt werden, wenn man die Kapazität der
    Speicherkanten $(v_t, v_{t+1}) \in H$ größer oder gleich $|D_i(v)|$ für
    $v \in S_i$ wählt. Wenn der Fluss diesen Bedarf übersteigen darf,
    muss die Kapazität entsprechend größer gewählt werden.
\end{remark}

\begin{example}
    Wir wollen uns ein einfaches Beispiel für ein zeiterweitertes Netzwerk 
    ansehen. Dazu sehen wir uns (Bild ..) an. In diesem deklarieren wir
    nur $s$ als Quelle und $t$ als Senke: $S^+ = \{s\}, S^- = \{t\}$.
    Wir betrachten $T = 6$ und damit $\timeDom = \{0, \ldots, 5\}$. An den
    Kanten sind die Zeiten $\tau$ notiert. Wir nehmen außerdem an, dass
    an den Knoten $u$ und $v$ Speicher zugelassen ist. Dann ergibt sich
    des Netzwerk $\tExp{T}$ in (Bild ...).
\end{example}

Da wir dynamische Flüsse in mit Hilfe von Algorithmen für statische Flüsse
konstruieren wollen, müssen wir zwischen Flüssen $f$ in $\graph$ und
Flüssen $x$ in $\tExp{T}$ wechseln können:

\begin{lemma}\label{lem:static_dyn_conv}
    Ein statischer Fluss $x$ in $\tExp{T}$ entspricht einem dynamischen Fluss
    $\func{f(e)}{\ropen{0,T}}{\R_+}$ in $\graph$ mit gleichem Flusswert und Kosten
    und umgekehrt. Dabei gilt:
    \begin{enumerate}
        \item $f_i(e,t) := x_i(e_{\lfloor t \rfloor})$ und
        \item $x_i(e_t) := \int_t^{t+1} f_i(e, \theta) d\theta$
    \end{enumerate}
        
    
    \begin{proof}
        TODO: S. 8,9.
    \end{proof}
\end{lemma}

Dieser Sachverhalt macht zwar sehr einfach, hat allerdings das Problem, dass das
Netzwerk $\tExp{T}$ sehr groß wird. Denn $|V^T| = |V| \cdot |\timeDom| = n \cdot T$.
Da aber $T$ in der Größe $log T$ kodiert wird, hängt $V^T$ nicht mehr polynomiell
von der Eingabe ab.

Die Idee ist nun, das Netzwerk $\tExp{T}$ wieder zu verkleinern, so dass es wieder
eine polynomielle Größe erreicht, indem unnötige Zeitschritte entfernt werden.
Das führt zu den \term{skalierten Netzwerken}:

\begin{definition}
    Sei $(\graph, \tau)$ Netzwerk und $0 < \Delta$, so dass $T/\Delta \in \N$
    und $\tau(e)/\Delta \in \N$ für alle $e \in \A$. Wir setzen
    $\tau'(e) := \tau(e)/\Delta$ für alle $e \in \A$
    und dann $\redNetw{T}{\Delta} := \tExp{T/\Delta}$ für $(\graph, \tau')$.
    
    Ein Knoten $v_t$ entspricht dann einem Zeitverlauf im Intervall
    $\ropen{t \Delta, (t+1) \Delta}$. Daher müssen die Kosten und Kapazitäten
    auf $c(e) \cdot \Delta$ und $u(e) \cdot \Delta$ korrigiert werden.
\end{definition}

\begin{lemma}
    Sei $0 < \Delta$ und $\graph$ wie oben. Dann entspricht ein statischer Fluss $x$
    in $\redNetw{T}{\Delta}$ einem Fluss $\func{f(e)}{\ropen{0, T}}{\R_+}$ in
    $\graph$ mit gleichen Kosten und umgekehrt.
    
    \begin{proof}
        Wende \lemRef{static_dyn_conv} auf $x$, dies ergibt einen Fluss
        $\func{\hat{f}(e)}{\ropen{0, T/\Delta}}{\R_+}$. Mit Skalierung der
        Zeit um $\Delta$ ergibt sich $f$. Der Rest ist klar.
    \end{proof}
\end{lemma}






